<style>
@font-face {
	font-family: octicons-link;
	src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
	-ms-text-size-adjust: 100%;
	-webkit-text-size-adjust: 100%;
	line-height: 1.5;
	color: #24292e;
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
	font-size: 16px;
	line-height: 1.5;
	word-wrap: break-word;
}

.markdown-body .pl-c {
	color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
	color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
	color: #6f42c1;
}

.markdown-body .pl-smi,
.markdown-body .pl-s .pl-s1 {
	color: #24292e;
}

.markdown-body .pl-ent {
	color: #22863a;
}

.markdown-body .pl-k {
	color: #d73a49;
}

.markdown-body .pl-s,
.markdown-body .pl-pds,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sre,
.markdown-body .pl-sr .pl-sra {
	color: #032f62;
}

.markdown-body .pl-v,
.markdown-body .pl-smw {
	color: #e36209;
}

.markdown-body .pl-bu {
	color: #b31d28;
}

.markdown-body .pl-ii {
	color: #fafbfc;
	background-color: #b31d28;
}

.markdown-body .pl-c2 {
	color: #fafbfc;
	background-color: #d73a49;
}

.markdown-body .pl-c2::before {
	content: "^M";
}

.markdown-body .pl-sr .pl-cce {
	font-weight: bold;
	color: #22863a;
}

.markdown-body .pl-ml {
	color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
	font-weight: bold;
	color: #005cc5;
}

.markdown-body .pl-mi {
	font-style: italic;
	color: #24292e;
}

.markdown-body .pl-mb {
	font-weight: bold;
	color: #24292e;
}

.markdown-body .pl-md {
	color: #b31d28;
	background-color: #ffeef0;
}

.markdown-body .pl-mi1 {
	color: #22863a;
	background-color: #f0fff4;
}

.markdown-body .pl-mc {
	color: #e36209;
	background-color: #ffebda;
}

.markdown-body .pl-mi2 {
	color: #f6f8fa;
	background-color: #005cc5;
}

.markdown-body .pl-mdr {
	font-weight: bold;
	color: #6f42c1;
}

.markdown-body .pl-ba {
	color: #586069;
}

.markdown-body .pl-sg {
	color: #959da5;
}

.markdown-body .pl-corl {
	text-decoration: underline;
	color: #032f62;
}

.markdown-body .octicon {
	display: inline-block;
	vertical-align: text-top;
	fill: currentColor;
}

.markdown-body a {
	background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
	outline-width: 0;
}

.markdown-body strong {
	font-weight: inherit;
}

.markdown-body strong {
	font-weight: bolder;
}

.markdown-body h1 {
	font-size: 2em;
	margin: 0.67em 0;
}

.markdown-body img {
	border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
	font-family: monospace, monospace;
	font-size: 1em;
}

.markdown-body hr {
	box-sizing: content-box;
	height: 0;
	overflow: visible;
}

.markdown-body input {
	font: inherit;
	margin: 0;
}

.markdown-body input {
	overflow: visible;
}

.markdown-body [type="checkbox"] {
	box-sizing: border-box;
	padding: 0;
}

.markdown-body * {
	box-sizing: border-box;
}

.markdown-body input {
	font-family: inherit;
	font-size: inherit;
	line-height: inherit;
}

.markdown-body a {
	color: #0366d6;
	text-decoration: none;
}

.markdown-body a:hover {
	text-decoration: underline;
}

.markdown-body strong {
	font-weight: 600;
}

.markdown-body hr {
	height: 0;
	margin: 15px 0;
	overflow: hidden;
	background: transparent;
	border: 0;
	border-bottom: 1px solid #dfe2e5;
}

.markdown-body hr::before {
	display: table;
	content: "";
}

.markdown-body hr::after {
	display: table;
	clear: both;
	content: "";
}

.markdown-body table {
	border-spacing: 0;
	border-collapse: collapse;
}

.markdown-body td,
.markdown-body th {
	padding: 0;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
	margin-top: 0;
	margin-bottom: 0;
}

.markdown-body h1 {
	font-size: 32px;
	font-weight: 600;
}

.markdown-body h2 {
	font-size: 24px;
	font-weight: 600;
}

.markdown-body h3 {
	font-size: 20px;
	font-weight: 600;
}

.markdown-body h4 {
	font-size: 16px;
	font-weight: 600;
}

.markdown-body h5 {
	font-size: 14px;
	font-weight: 600;
}

.markdown-body h6 {
	font-size: 12px;
	font-weight: 600;
}

.markdown-body p {
	margin-top: 0;
	margin-bottom: 10px;
}

.markdown-body blockquote {
	margin: 0;
}

.markdown-body ul,
.markdown-body ol {
	padding-left: 0;
	margin-top: 0;
	margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
	x-list-style-type: lower-roman;
	  list-style-type: decimal;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
	list-style-type: lower-alpha;
}

.markdown-body dd {
	margin-left: 0;
}

.markdown-body code {
	font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
	font-size: 12px;
}

.markdown-body pre {
	margin-top: 0;
	margin-bottom: 0;
	font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
	font-size: 12px;
}

.markdown-body .octicon {
	vertical-align: text-bottom;
}

.markdown-body .pl-0 {
	padding-left: 0 !important;
}

.markdown-body .pl-1 {
	padding-left: 4px !important;
}

.markdown-body .pl-2 {
	padding-left: 8px !important;
}

.markdown-body .pl-3 {
	padding-left: 16px !important;
}

.markdown-body .pl-4 {
	padding-left: 24px !important;
}

.markdown-body .pl-5 {
	padding-left: 32px !important;
}

.markdown-body .pl-6 {
	padding-left: 40px !important;
}

.markdown-body::before {
	display: table;
	content: "";
}

.markdown-body::after {
	display: table;
	clear: both;
	content: "";
}

.markdown-body>*:first-child {
	margin-top: 0 !important;
}

.markdown-body>*:last-child {
	margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
	color: inherit;
	text-decoration: none;
}

.markdown-body .anchor {
	float: left;
	padding-right: 4px;
	margin-left: -20px;
	line-height: 1;
}

.markdown-body .anchor:focus {
	outline: none;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
	margin-top: 0;
	margin-bottom: 16px;
}

.markdown-body hr {
	height: 0.25em;
	padding: 0;
	margin: 24px 0;
	background-color: #e1e4e8;
	border: 0;
}

.markdown-body blockquote {
	padding: 0 1em;
	color: #6a737d;
	border-left: 0.25em solid #dfe2e5;
}

.markdown-body blockquote>:first-child {
	margin-top: 0;
}

.markdown-body blockquote>:last-child {
	margin-bottom: 0;
}

.markdown-body kbd {
	display: inline-block;
	padding: 3px 5px;
	font-size: 11px;
	line-height: 10px;
	color: #444d56;
	vertical-align: middle;
	background-color: #fafbfc;
	border: solid 1px #c6cbd1;
	border-bottom-color: #959da5;
	border-radius: 3px;
	box-shadow: inset 0 -1px 0 #959da5;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
	margin-top: 24px;
	margin-bottom: 16px;
	font-weight: 600;
	line-height: 1.25;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
	color: #1b1f23;
	vertical-align: middle;
	visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
	text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
	visibility: visible;
}

.markdown-body h1 {
	padding-bottom: 0.3em;
	font-size: 2em;
	border-bottom: 1px solid #eaecef;
}

.markdown-body h2 {
	padding-bottom: 0.3em;
	font-size: 1.5em;
	border-bottom: 1px solid #eaecef;
}

.markdown-body h3 {
	font-size: 1.25em;
}

.markdown-body h4 {
	font-size: 1em;
}

.markdown-body h5 {
	font-size: 0.875em;
}

.markdown-body h6 {
	font-size: 0.85em;
	color: #6a737d;
}

.markdown-body ul,
.markdown-body ol {
	padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
	margin-top: 0;
	margin-bottom: 0;
}

.markdown-body li {
	word-wrap: break-all;
}

.markdown-body li>p {
	margin-top: 16px;
}

.markdown-body li+li {
	margin-top: 0.25em;
}

.markdown-body dl {
	padding: 0;
}

.markdown-body dl dt {
	padding: 0;
	margin-top: 16px;
	font-size: 1em;
	font-style: italic;
	font-weight: 600;
}

.markdown-body dl dd {
	padding: 0 16px;
	margin-bottom: 16px;
}

.markdown-body table {
	display: block;
	width: 100%;
	overflow: auto;
}

.markdown-body table th {
	font-weight: 600;
}

.markdown-body table th,
.markdown-body table td {
	padding: 6px 13px;
	border: 1px solid #dfe2e5;
}

.markdown-body table tr {
	background-color: #fff;
	border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
	background-color: #f6f8fa;
}

.markdown-body img {
	max-width: 100%;
	box-sizing: content-box;
	background-color: #fff;
}

.markdown-body img[align=right] {
	padding-left: 20px;
}

.markdown-body img[align=left] {
	padding-right: 20px;
}

.markdown-body code {
	padding: 0.2em 0.4em;
	margin: 0;
	font-size: 85%;
	background-color: rgba(27,31,35,0.05);
	border-radius: 3px;
}

.markdown-body pre {
	word-wrap: normal;
}

.markdown-body pre>code {
	padding: 0;
	margin: 0;
	font-size: 100%;
	word-break: normal;
	white-space: pre;
	background: transparent;
	border: 0;
}

.markdown-body .highlight {
	margin-bottom: 16px;
}

.markdown-body .highlight pre {
	margin-bottom: 0;
	word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
	padding: 16px;
	overflow: auto;
	font-size: 85%;
	line-height: 1.45;
	background-color: #f6f8fa;
	border-radius: 3px;
}

.markdown-body pre code {
	display: inline;
	max-width: auto;
	padding: 0;
	margin: 0;
	overflow: visible;
	line-height: inherit;
	word-wrap: normal;
	background-color: transparent;
	border: 0;
}

.markdown-body .full-commit .btn-outline:not(:disabled):hover {
	color: #005cc5;
	border-color: #005cc5;
}

.markdown-body kbd {
	display: inline-block;
	padding: 3px 5px;
	font: 11px "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
	line-height: 10px;
	color: #444d56;
	vertical-align: middle;
	background-color: #fafbfc;
	border: solid 1px #d1d5da;
	border-bottom-color: #c6cbd1;
	border-radius: 3px;
	box-shadow: inset 0 -1px 0 #c6cbd1;
}

.markdown-body :checked+.radio-label {
	position: relative;
	z-index: 1;
	border-color: #0366d6;
}

.markdown-body .task-list-item {
	list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
	margin-top: 3px;
}

.markdown-body .task-list-item input {
	margin: 0 0.2em 0.25em -1.6em;
	vertical-align: middle;
}

.markdown-body hr {
	border-bottom-color: #eee;
}

</style>
<style>
ol {
    display: block;
    list-style-type: decimal;
}
</style>

<div class="markdown-body">

<style>
.pagebreak { page-break-before: always; }
</style>

<h1>Lecture 13 - Go Concurrency / Start of Smart Contracts</h1>

<h1>Concurrency in Go</h1>

<h2>Go routines</h2>

<p>A Go Routine:</p>

<pre><code>	go func( a int ) {
		fmt.Printf ( &quot;a=%d\n&quot;, a )
	}( 12 )
</code></pre>

<p>10 Go Routines:</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
	for i := 0; i &lt; 10; i++ {
		go func(a int) {
			fmt.Printf(&quot;a=%d\n&quot;, a)
		}(12 + i)
	}
}
</code></pre>

<p>With NO output - Why?</p>

<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
)

func main() {
    var wg sync.WaitGroup
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go func(a int) {
			defer wg.Done()
			fmt.Printf(&quot;a=%d\n&quot;, a)
		}(12 + i)
	}
    wg.Wait()
}
</code></pre>

<p>And OUTPUT!!!!</p>

<pre><code>$ go run go-r2.go
a=17
a=19
a=12
a=21
a=13
a=16
a=14
a=20
a=15
a=18
</code></pre>

<h2>locks</h2>

<p>From: <a href="https://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/">https://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/</a></p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func main() {
    messages := make(chan int)
    var wg sync.WaitGroup

    // you can also add these one at 
    // a time if you need to 

    wg.Add(3)
    go func() {
        defer wg.Done()
        time.Sleep(time.Second * 3)
        messages &lt;- 1
    }()
    go func() {
        defer wg.Done()
        time.Sleep(time.Second * 2)
        messages &lt;- 2
    }() 
    go func() {
        defer wg.Done()
        time.Sleep(time.Second * 1)
        messages &lt;- 3
    }()
    go func() {
        for i := range messages {
            fmt.Println(i)
        }
    }()

    wg.Wait()
}
</code></pre>

<p>Also &ldquo;map&rdquo;&rsquo;s are not concurrency protected.  You have to lock/unlock them
yourself.</p>

<p>Problems like this are easy to find.  There is a &ldquo;race detector&rdquo; built into
go and you can run it as a part of your tests.</p>

<p>You should decide if you need to protect a map.  Why? When?</p>

<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;sync&quot;
	&quot;sync/atomic&quot;
	&quot;time&quot;
)

func main() {
	state := make(map[int]int)
	mutex := &amp;sync.Mutex{}

	var nRead uint64
	var nWrite uint64

	const randRange = 15

	for ii := 0; ii &lt; 100; ii++ {
		go func() {
			total := 0
			for {
				key := rand.Intn(randRange)
				mutex.Lock()
				total += state[key]
				mutex.Unlock()
				atomic.AddUint64(&amp;nRead, 1)
				time.Sleep(time.Millisecond)
			}
		}()
	}
	for jj := 0; jj &lt; 50; jj++ {
		go func() {
			for {
				key := rand.Intn(randRange)
				val := rand.Intn(100)
				mutex.Lock()
				state[key] = val
				mutex.Unlock()
				atomic.AddUint64(&amp;nWrite, 1)
				time.Sleep(time.Millisecond)
			}
		}()
	}

	time.Sleep(time.Second * 1)

	nReadTotal := atomic.LoadUint64(&amp;nRead)
	nWriteTotal := atomic.LoadUint64(&amp;nWrite)

	mutex.Lock()
	fmt.Printf(&quot;ReadOps: %d\nWriteOps: %d\nFinal State: %+v\n&quot;, nReadTotal, nWriteTotal, state)
	mutex.Unlock()

}

</code></pre>

<p>The Output</p>

<pre><code>$ go run atomic.go
ReadOps: 81881
WriteOps: 40936
Final State: map[10:70 3:81 9:81 12:55 5:67 1:38 6:89 14:28 0:40 8:13 4:11 13:19 2:40 11:23 7:30]
$ go run atomic.go
ReadOps: 82500
WriteOps: 41250
Final State: map[2:34 10:2 4:28 5:80 14:42 0:46 3:55 1:65 12:63 9:10 13:50 7:17 6:19 11:91 8:14]
</code></pre>

<h2>channels</h2>

<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

func main() {
	msg := make(chan string)
	msg2 := make(chan string)
	var wg sync.WaitGroup
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go func(n int) {
			for {
				time.Sleep(time.Millisecond * 50)
				msg &lt;- fmt.Sprintf(&quot;ping:%d&quot;, n)
			}
		}(i)
	}
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go func(n int) {
			for {
				time.Sleep(time.Millisecond * 55)
				msg2 &lt;- fmt.Sprintf(&quot;PONG:%d&quot;, n)
			}
		}(i)
	}
	nMsg := 0
	for {
		select {
		case out := &lt;-msg:
			nMsg++
			fmt.Printf(&quot;%s\n&quot;, out)
		case out := &lt;-msg2:
			nMsg++
			fmt.Printf(&quot;%s\n&quot;, out)
		}
		if nMsg &gt; 100 {
			os.Exit(0)
		}
	}
	wg.Wait()
}
</code></pre>

<p>Output:</p>

<pre><code>$ go run chan.go
ping:1
ping:6
ping:0
ping:5
ping:9
ping:7
ping:8
ping:2
ping:3
ping:4
PONG:3
PONG:5
PONG:4
PONG:8
PONG:7
PONG:1
PONG:2
PONG:9
PONG:6
PONG:0
ping:1
...
</code></pre>

<h1>Smart Contracts - Standard Contracts (ERC-20)</h1>

<h2>Standard ERC-20 Contract</h2>

<h3>SimpleToken</h3>

<table>
<thead>
<tr>
<th>Method Name</th>
<th>Const</th>
<th>$</th>
<th>Params</th>
</tr>
</thead>

<tbody>
<tr>
<td>Approval</td>
<td>event</td>
<td></td>
<td><code>( address owner, address spender, uint256 value )</code></td>
</tr>

<tr>
<td>INITIAL_SUPPLY</td>
<td>const</td>
<td></td>
<td><code>() returns ( uint256 )</code></td>
</tr>

<tr>
<td>Transfer</td>
<td>event</td>
<td></td>
<td><code>( address from, address to, uint256 value )</code></td>
</tr>

<tr>
<td>allowance</td>
<td>const</td>
<td></td>
<td><code>( address _owner, address _spender ) returns ( uint256 )</code></td>
</tr>

<tr>
<td>approve</td>
<td>Tx</td>
<td></td>
<td><code>( address _spender, uint256 _value ) returns ( bool )</code></td>
</tr>

<tr>
<td>balanceOf</td>
<td>const</td>
<td></td>
<td><code>( address _owner ) returns ( uint256 )</code></td>
</tr>

<tr>
<td>decimals</td>
<td>const</td>
<td></td>
<td><code>() returns ( uint8 )</code></td>
</tr>

<tr>
<td>decreaseApproval</td>
<td>Tx</td>
<td></td>
<td><code>( address _spender, uint256 _subtractedValue ) returns ( bool )</code></td>
</tr>

<tr>
<td>increaseApproval</td>
<td>Tx</td>
<td></td>
<td><code>( address _spender, uint256 _addedValue ) returns ( bool )</code></td>
</tr>

<tr>
<td>name</td>
<td>const</td>
<td></td>
<td><code>() returns ( string )</code></td>
</tr>

<tr>
<td>symbol</td>
<td>const</td>
<td></td>
<td><code>() returns ( string )</code></td>
</tr>

<tr>
<td>totalSupply</td>
<td>const</td>
<td></td>
<td><code>() returns ( uint256 )</code></td>
</tr>

<tr>
<td>transfer</td>
<td>Tx</td>
<td></td>
<td><code>( address _to, uint256 _value ) returns ( bool )</code></td>
</tr>

<tr>
<td>transferFrom</td>
<td>Tx</td>
<td></td>
<td><code>( address _from, address _to, uint256 _value ) returns ( bool )</code></td>
</tr>

<tr>
<td>constructor</td>
<td>()</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<h3>SimpleToken Ours derived from StandardToken</h3>

<pre><code>
pragma solidity ^0.4.24;

import &quot;openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol&quot;;

/**
 * @title SimpleToken
 * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.
 * Note they can later distribute these tokens as they wish using `transfer` and other
 * `StandardToken` functions.
 */
contract SimpleToken is StandardToken {

	string public constant name = &quot;SimpleToken&quot;; // solium-disable-line uppercase
	string public constant symbol = &quot;SIM&quot;; // solium-disable-line uppercase
	uint8 public constant decimals = 0; // solium-disable-line uppercase

	uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals));

	/**
	 * @dev Constructor that gives msg.sender all of existing tokens.
	 */
	constructor() public {
		totalSupply_ = INITIAL_SUPPLY;
		balances[msg.sender] = INITIAL_SUPPLY;
		emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);
	}

}
</code></pre>

<div class="pagebreak"></div>

<h3>StandardToken</h3>

<pre><code>pragma solidity ^0.4.24;

import &quot;./BasicToken.sol&quot;;
import &quot;./ERC20.sol&quot;;


/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * https://github.com/ethereum/EIPs/issues/20
 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is ERC20, BasicToken {

  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;


  /**
   * @dev Transfer tokens from one address to another
   * @param _from address The address which you want to send tokens from
   * @param _to address The address which you want to transfer to
   * @param _value uint256 the amount of tokens to be transferred
   */
  function transferFrom(
    address _from,
    address _to,
    uint256 _value
  )
    public
    returns (bool)
  {
    require(_to != address(0));
    require(_value &lt;= balances[_from]);
    require(_value &lt;= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  /**
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
   * Beware that changing an allowance with this method brings the risk that someone may use both the old
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   * @param _spender The address which will spend the funds.
   * @param _value The amount of tokens to be spent.
   */
  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  /**
   * @dev Function to check the amount of tokens that an owner allowed to a spender.
   * @param _owner address The address which owns the funds.
   * @param _spender address The address which will spend the funds.
   * @return A uint256 specifying the amount of tokens still available for the spender.
   */
  function allowance(
    address _owner,
    address _spender
   )
    public
    view
    returns (uint256)
  {
    return allowed[_owner][_spender];
  }

  /**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(
    address _spender,
    uint256 _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(
    address _spender,
    uint256 _subtractedValue
  )
    public
    returns (bool)
  {
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue &gt; oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}

</code></pre>

<h3>BasicToken</h3>

<pre><code>
pragma solidity ^0.4.24;


import &quot;./ERC20Basic.sol&quot;;
import &quot;../../math/SafeMath.sol&quot;;


/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address =&gt; uint256) balances;

  uint256 totalSupply_;

  /**
  * @dev Total number of tokens in existence
  */
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev Transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value &lt;= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

}

</code></pre>

<h3>ERC20</h3>

<pre><code>
pragma solidity ^0.4.24;

import &quot;./ERC20Basic.sol&quot;;


/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender)
    public view returns (uint256);

  function transferFrom(address from, address to, uint256 value)
    public returns (bool);

  function approve(address spender, uint256 value) public returns (bool);
  event Approval(
    address indexed owner,
    address indexed spender,
    uint256 value
  );
}

</code></pre>

</div>

